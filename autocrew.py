AUTOCREW_VERSION = "2.1.0"

# Please do not edit this file directly
# Please modify the config file, "config.ini"
# If you experience any errors, please upload the complete log file, "autocrew.log", along with your issue on GitHub:
# https://github.com/yanniedog/autocrew/issues/new 



import argparse
import configparser
import copy
import csv
import io
import json
import logging
import os
import re
import requests
import shutil
import subprocess
import sys
import tiktoken
import time
import argparse
from core import AutoCrew
from datetime import datetime
from packaging import version
from typing import Any, Dict, List

from crewai import Agent, Crew, Process, Task
from langchain_community.llms import Ollama
from langchain_community.tools import DuckDuckGoSearchRun
from langchain.callbacks.manager import CallbackManager
from langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler
from openai import OpenAI



GREEK_ALPHABETS = ["alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa",
                       "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigma", "tau", "upsilon"]



def install_dependencies():
    # Check if 'requirements.txt' exists in the current working directory
    requirements_file = 'requirements.txt'
    if not os.path.exists(requirements_file):
        raise FileNotFoundError(f"{requirements_file} not found in the current working directory.")

    # Check if 'pip' is available
    pip_executable = shutil.which('pip') or shutil.which('pip3')
    if not pip_executable:
        raise EnvironmentError("pip is not available on the system.")

    logging.info("Installing dependencies...")

    # Run the pip install command and capture the output
    result = subprocess.run([pip_executable, 'install', '-r', requirements_file], capture_output=True, text=True)

    # Check if the installation was successful
    if result.returncode != 0:
        # If there was an error, print the error message and raise an exception
        logging.error("Error occurred while installing dependencies:")
        logging.error(result.stdout)
        logging.error(result.stderr)

        raise RuntimeError("Failed to install dependencies.")
    else:
        print("Dependencies installed successfully.")

    
def initialize_logging(verbose=False, on_screen_logging_level='INFO', message=None):
    log_file = os.path.join(os.getcwd(), 'autocrew.log')

    # Set up the logger to write to the log file
    file_handler = logging.FileHandler(log_file, mode='w')
    file_handler.setLevel(logging.DEBUG)  # Always set to DEBUG for the log file
    file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - (%(filename)s,%(funcName)s,%(lineno)d) - %(message)s'))
    # Set up the logger to write to the console
    console_handler = logging.StreamHandler(sys.stdout)
    console_level = getattr(logging, on_screen_logging_level.upper(), logging.INFO)
    console_handler.setLevel(console_level)
    # Modify the formatter to only display the message
    console_handler.setFormatter(logging.Formatter('%(message)s'))

    # Get the root logger and add the handlers to it
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # Set the root logger level to DEBUG to capture all logs
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    # Ensure that all other loggers use the root logger's configuration
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)
    logging.root.addHandler(file_handler)
    logging.root.addHandler(console_handler)

    # Log the initial message at the top of the log file if provided
    if message:
        logger.info(message)

    # Log the script version number
    logger.debug(f"AutoCrew version: {AUTOCREW_VERSION}")



def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, (KeyboardInterrupt, SystemExit)):
        # Call the default KeyboardInterrupt or SystemExit handler
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logging.error("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))


def positive_int(value):
        try:
            ivalue = int(value)
            if ivalue <= 0:
                raise argparse.ArgumentTypeError(f"{value} is an invalid positive int value")
            return ivalue
        except ValueError:
            print("Please specify the total number of alternative scripts to generate: ")
            while True:
                try:
                    return int(input())
                except ValueError:
                    print("Invalid input. Please enter a valid number.")             
    

def main():
    # Set the global exception handler
    sys.excepthook = handle_exception

    # Manually parse the -m option with a value directly attached
    multiple_value = None
    remaining_args = []
    for arg in sys.argv[1:]:  # Skip the script name
        if arg.startswith('-m') and len(arg) > 2:
            try:
                multiple_value = int(arg[2:])
            except ValueError:
                print("The -m option requires a number directly attached to it, e.g., -m3")
                sys.exit(1)
        else:
            remaining_args.append(arg)

    # Parse the remaining command line arguments
    parser = argparse.ArgumentParser(description='CrewAI Autocrew Script')
    parser.add_argument('-v', '--verbose', action='store_true', help='Provide additional details during execution')
    parser.add_argument('overall_goal', nargs='?', type=str, help='The overall goal for the crew')
    parser.add_argument('-r', '--rank', action='store_true', help='Rank the generated crews if multiple scripts are created')
    parser.add_argument('-a', '--auto_run', action='store_true', help='Automatically run the scripts after generation')
    args = parser.parse_args(remaining_args)
    
    # Initialize logging after parsing arguments
    initialize_logging(verbose=args.verbose)

    # Set the multiple value if it was parsed manually
    if multiple_value is not None:
        args.multiple = multiple_value

    if args.overall_goal is None:
        args.overall_goal = input("Please set the overall goal for your crew: ")

    autocrew = AutoCrew()

    # Log the redacted config.ini content
    autocrew.log_config_with_redacted_api_keys()

    try:
        if hasattr(args, 'multiple') and args.multiple:
            csv_file_paths = autocrew.generate_scripts(args.overall_goal, args.multiple)
            if args.rank:
                ranked_crews, overall_summary = autocrew.rank_crews(csv_file_paths, args.overall_goal, args.verbose)
                logging.debug(f"\nRanking prompt:\n{overall_summary}\n")
                autocrew.save_ranking_output(ranked_crews, args.overall_goal)
            if args.auto_run:
                for path in csv_file_paths:
                    script_path = path.replace('.csv', '.py')  # Change the file extension to .py
                    subprocess.run([sys.executable, script_path])  # Using sys.executable
        elif args.rank:
            csv_file_paths = autocrew.get_existing_scripts(args.overall_goal)
            ranked_crews, overall_summary = autocrew.rank_crews(csv_file_paths, args.overall_goal, args.verbose)
            logging.debug(f"\nRanking prompt:\n{overall_summary}\n")
            autocrew.save_ranking_output(ranked_crews, args.overall_goal)
            if args.auto_run:
                subprocess.run([sys.executable, ranked_crews[0][0]])
        else:
            autocrew.run(args.overall_goal, None, args.auto_run, args.verbose)
    except Exception as e:
        logging.exception("An error occurred during script execution.")
        sys.exit(1)

if __name__ == '__main__':
    main()
