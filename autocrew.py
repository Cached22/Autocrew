
# filename: autocrew.py
#####################################################################################################################
AUTOCREW_VERSION = "2.1.2"

# Please do not edit this file directly
# Please modify the config file, "config.ini"
# If you experience any errors, please upload the complete log file, "autocrew.log", along with your issue on GitHub:
# https://github.com/yanniedog/autocrew/issues/new 
#####################################################################################################################



import argparse
import configparser
import copy
import csv
import io
import json
import logging
import os
import re
import requests
import shutil
import subprocess
import sys
import tiktoken
import time
import argparse

from core import AutoCrew
from datetime import datetime
from packaging import version
from typing import Any, Dict, List

from crewai import Agent, Crew, Process, Task
from langchain_community.llms import Ollama
from langchain_community.tools import DuckDuckGoSearchRun
from langchain.callbacks.manager import CallbackManager
from langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler
from openai import OpenAI



GREEK_ALPHABETS = ["alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa",
                       "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigma", "tau", "upsilon"]



def install_dependencies():
    # Check if 'requirements.txt' exists in the current working directory
    requirements_file = 'requirements.txt'
    if not os.path.exists(requirements_file):
        raise FileNotFoundError(f"{requirements_file} not found in the current working directory.")

    # Check if 'pip' is available
    pip_executable = shutil.which('pip') or shutil.which('pip3')
    if not pip_executable:
        raise EnvironmentError("pip is not available on the system.")

    logging.info("Installing dependencies...")

    # Run the pip install command and capture the output
    result = subprocess.run([pip_executable, 'install', '-r', requirements_file], capture_output=True, text=True)

    # Check if the installation was successful
    if result.returncode != 0:
        # If there was an error, print the error message and raise an exception
        logging.error("Error occurred while installing dependencies:")
        logging.error(result.stdout)
        logging.error(result.stderr)

        raise RuntimeError("Failed to install dependencies.")
    else:
        print("Dependencies installed successfully.")

    
def initialize_logging(verbose=False, on_screen_logging_level='INFO', message=None):
    log_file = os.path.join(os.getcwd(), 'autocrew.log')

    # File Handler Configuration
    file_handler = logging.FileHandler(log_file, mode='w')
    file_handler.setLevel(logging.DEBUG)
    file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - (%(filename)s,%(funcName)s,%(lineno)d) - %(message)s')
    file_handler.setFormatter(file_formatter)

    # Console Handler Configuration
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(getattr(logging, on_screen_logging_level.upper(), logging.INFO))
    console_formatter = logging.Formatter('%(message)s')
    console_handler.setFormatter(console_formatter)

    # Logger Configuration
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    # Log the initial message and script version number
    if message:
        logger.info(message)

    # If verbose flag is set, update the console handler to log DEBUG messages
    if verbose:
        console_handler.setLevel(logging.DEBUG)








def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, (KeyboardInterrupt, SystemExit)):
        # Call the default KeyboardInterrupt or SystemExit handler
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logging.error("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))


def positive_int(value):
        try:
            ivalue = int(value)
            if ivalue <= 0:
                raise argparse.ArgumentTypeError(f"{value} is an invalid positive int value")
            return ivalue
        except ValueError:
            print("Please specify the total number of alternative scripts to generate: ")
            while True:
                try:
                    return int(input())
                except ValueError:
                    print("Invalid input. Please enter a valid number.")             

def check_latest_version():
    try:
        response = requests.get('https://api.github.com/repos/yanniedog/autocrew/releases/latest')
        response.raise_for_status()
        latest_release = response.json()
        latest_version = latest_release['tag_name']

        if version.parse(latest_version) > version.parse(AUTOCREW_VERSION):
            print(f"An updated version of AutoCrew is available: {latest_version}")
            print("Before upgrading, please ensure you have backed up your entire 'autocrew' directory (including subdirectories).")
            print("You can upgrade to the latest version by running the script with the -u or --upgrade parameter.")
            return latest_version
        else:
            print("You are running the latest version of AutoCrew.")
            return None
    except Exception as e:
        print(f"Error checking for the latest version: {e}")
        return None


    
def upgrade_autocrew(latest_version):
    # Create a hidden backup directory if it doesn't exist
    backup_dir = '.backup'
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)
    
    # Backup the current logfile
    logfile_path = 'autocrew.log'
    logfile_backup_name = f'autocrew-upgrade-logfile_(v-{AUTOCREW_VERSION}--to--v-{latest_version}).log'
    logfile_backup_path = os.path.join(backup_dir, logfile_backup_name)
    if os.path.exists(logfile_path):
        shutil.copyfile(logfile_path, logfile_backup_path)
        print(f"Backing up the current logfile to {logfile_backup_path}...")

    # Perform a backup of the current config.ini file
    config_backup_path = os.path.join(backup_dir, 'config_backup.ini')
    shutil.copyfile('config.ini', config_backup_path)
    print("Backing up the current config.ini file...")

    # Clone the repository (you may want to specify a temporary directory)
    print("Cloning the latest version from GitHub...")
    subprocess.run(['git', 'clone', 'https://github.com/yanniedog/autocrew.git', 'autocrew_update'])

    # Copy the new autocrew.py and other files, excluding config.ini
    update_dir = 'autocrew_update'
    for filename in os.listdir(update_dir):
        source_path = os.path.join(update_dir, filename)
        if os.path.isfile(source_path) and filename != 'config.ini':
            shutil.copyfile(source_path, filename)

    print("Updating the config.ini file with your previous settings...")
    config = configparser.ConfigParser()
    config.read(os.path.join(update_dir, 'config.ini'))
    config_backup = configparser.ConfigParser()
    config_backup.read(config_backup_path)
    for section in config_backup.sections():
        if not config.has_section(section):
            config.add_section(section)  # Add the missing section
        for key, value in config_backup.items(section):
            config.set(section, key, value)
    with open('config.ini', 'w') as configfile:
        config.write(configfile)

    # Clean up: remove the update directory
    shutil.rmtree(update_dir)
    print("Update complete. Restarting the script...")

    # Restart the script using a subprocess
    os.execv(sys.executable, ['python'] + sys.argv)
    
def main():
    # Set the global exception handler
    sys.excepthook = handle_exception

    # Initialize logging with the default verbosity level and initial message
    startup_message = (
        f"\nAutoCrew version: {AUTOCREW_VERSION}\n"
        "\n"
        "Settings can be modified within \"config.ini\"\n"
        "Generated scripts are saved in the \"scripts\" subdirectory\n"
        "If you experience any errors, please create an issue on Github and attach \"autocrew.log\":\n"
        "https://github.com/yanniedog/autocrew/issues/new\n"
        "\n"
        "Use the -? or -h command line options to display help information.\n"
    )
    initialize_logging(verbose=False, on_screen_logging_level='INFO', message=startup_message)

    # Parse command line arguments
    parser = argparse.ArgumentParser(description='CrewAI Autocrew Script', add_help=False)
    parser.add_argument('-v', '--verbose', action='store_true', help='Provide additional details during execution')
    parser.add_argument('-u', '--upgrade', action='store_true', help='Upgrade to the latest version of AutoCrew (ensure you have backed up your entire autocrew directory, and any subdirectories within it, beforehand)')  # Updated help info
    parser.add_argument('-h', '-?', '--help', action='store_true', help='Show this help message and exit')
    parser.add_argument('overall_goal', nargs='?', type=str, help='The overall goal for the crew')
    parser.add_argument('-r', '--rank', action='store_true', help='Rank the generated crews if multiple scripts are created')
    parser.add_argument('-a', '--auto_run', action='store_true', help='Automatically run the scripts after generation')
    args, unknown_args = parser.parse_known_args()

    # Check if -upgrade or -h/-?/--help is used with other parameters
    if args.upgrade or args.help:
        if unknown_args:  # If there are other arguments
            parser.print_usage()
            print(f"Error: The '-u/--upgrade' and '-h/-?/--help' options cannot be used with other arguments.")
            sys.exit(1)
        elif args.upgrade:
            latest_version = check_latest_version()
            if latest_version and version.parse(latest_version) > version.parse(AUTOCREW_VERSION):
                upgrade_autocrew(latest_version)
            else:
                print("No new version available or you are already running the latest version.")
            sys.exit(0)
        elif args.help:
            parser.print_help()
            sys.exit(0)

    # Check for the latest version and inform the user about the upgrade option
    check_latest_version()

    # Update the logger's level if verbose flag is set
    if args.verbose:
        for handler in logging.getLogger().handlers:
            if isinstance(handler, logging.StreamHandler):
                handler.setLevel(logging.DEBUG)

    if args.overall_goal is None:
        args.overall_goal = input("Please set the overall goal for your crew: ")

    autocrew = AutoCrew()

    # Log the redacted config.ini content
    autocrew.log_config_with_redacted_api_keys()
    
    try:
        if hasattr(args, 'multiple') and args.multiple:
            csv_file_paths = autocrew.generate_scripts(args.overall_goal, args.multiple)
            if args.rank:
                ranked_crews, overall_summary = autocrew.rank_crews(csv_file_paths, args.overall_goal, args.verbose)
                logging.debug(f"\nRanking prompt:\n{overall_summary}\n")
                autocrew.save_ranking_output(ranked_crews, args.overall_goal)
            if args.auto_run:
                for path in csv_file_paths:
                    script_path = path.replace('.csv', '.py')  # Change the file extension to .py
                    subprocess.run([sys.executable, script_path])  # Using sys.executable
        elif args.rank:
            csv_file_paths = autocrew.get_existing_scripts(args.overall_goal)
            ranked_crews, overall_summary = autocrew.rank_crews(csv_file_paths, args.overall_goal, args.verbose)
            logging.debug(f"\nRanking prompt:\n{overall_summary}\n")
            autocrew.save_ranking_output(ranked_crews, args.overall_goal)
            if args.auto_run:
                subprocess.run([sys.executable, ranked_crews[0][0]])
        else:
            autocrew.run(args.overall_goal, None, args.auto_run, args.verbose)
    except Exception as e:
        logging.exception("An error occurred during script execution.")
        sys.exit(1)

if __name__ == '__main__':
    main()
